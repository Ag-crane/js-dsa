# 최장 공통 부분 수열 (LCS, Longest Common Subsequence)

## 1. 정의

두 문자열이 주어졌을 때, **공통으로 들어있는 가장 긴 부분 수열을 찾는 문제**이다.

-   예시:

```
문자열1 : "ABCBDAB"
문자열2 : "BDCABA"

두 문자열의 LCS 중 하나는 "BCBA"이다.
(다른 LCS로는 "BDAB", "BCAB" 등이 존재할 수 있음)
```

여기서 부분 수열은 연속되지 않아도 되며, 순서만 유지하면 된다.
LCS는 여러 개가 존재할 수 있다.

---

## 2. DP를 활용한 LCS의 길이 구하기

다음과 같은 아이디어를 사용한다.

-   두 문자열 `A`, `B`의 길이를 각각 `n`, `m`이라 하고,
    `dp[i][j]`를 문자열 `A`의 첫 `i`글자(`A[0...i-1]`)와 문자열 `B`의 첫 `j`글자(`B[0...j-1]`) 사이의 LCS 길이 라고 정의한다.

-   이렇게 정의하면 DP 테이블의 값을 계산할 때, 다음 두 가지 경우로 나뉜다.

### DP 점화식 (핵심)

문자열 `A`와 `B`의 특정 문자 (`A[i-1]`, `B[j-1]`)를 비교하여 점화식을 세운다.

1. **두 문자가 같은 경우**

-   두 문자가 같다면 이 문자는 공통 부분 수열에 포함된다.

```js
dp[i][j] = dp[i - 1][j - 1] + 1;
```

2. **두 문자가 다른 경우**

-   두 문자가 다르면, 이전 단계 중 최대값을 가져온다.

```js
dp[i][j] = Math.max((dp[i-1][j], dp[i][j-1])
```

위 규칙을 통해 DP 테이블을 채우면, `dp[n][m]`이 LCS의 길이가 된다.

---

### DP 테이블 예시

아래는 예시 문자열 `"ABCBDAB"`와 `"BDCABA"`의 DP 테이블이다.

```css
    B D C A B A
  0 0 0 0 0 0 0
A 0 0 0 0 1 1 1
B 0 1 1 1 1 2 2
C 0 1 1 2 2 2 2
B 0 1 1 2 2 3 3
D 0 1 2 2 2 3 3
A 0 1 2 2 3 3 4
B 0 1 2 2 3 4 4
```

-   이 테이블에서 최종 LCS 길이는 오른쪽 아래 값인 `dp[7][6] = 4`이다.

## 3. 역추적으로 LCS 구하기

-   테이블을 다 채운 뒤, 맨 오른쪽 아래(`dp[n][m]`)에서부터 시작하여 거꾸로 올라가면서 추적한다.

-   `(i, j)`를 `i = n`, `j = m`에서 시작하여 아래 규칙에 따라 감소시킨다.

1. 두 문자가 일치하는 경우 (`A[i-1] === B[j-1]`)

    - 현재 확인하는 위치에서 문자열 A와 B의 문자가 같다면, **이 문자는 LCS의 일부분이다** .

    - 따라서 현재 문자를 결과에 추가하고, **대각선 위쪽** 으로 이동한다.

2. 두 문자가 일치하지 않는 경우 (`A[i-1] !== B[j-1]`)

    - 이때는 `dp[i-1][j]`와 `dp[i][j-1]` 중에서 **더 큰 값을 갖는 쪽으로 이동** 한다.

    - 같은 값이라면 어느 쪽으로 가도 무방하니 한 방향을 고정 선택하여 이동한다.

    - 예를 들어, `dp[i-1][j] > dp[i][j-1]`라면 위쪽(`dp[i-1][j]`)으로 이동

    - 아니라면 왼쪽(`dp[i][j-1]`)으로 이동
