# 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)

이분탐색을 활용하면 O(NlogN)으로 풀 수 있다.
[DP 방식의 O(N^2) 풀이](https://github.com/Ag-crane/js-dsa/tree/main/algorithms/dynamic-programming/LIS)에 비해 훨씬 효율적이지만,
이해와 구현이 조금 복잡할 수 있다.

처음 접할 시에 스스로 이해하기 어려운 풀이이므로
아이디어와 사고 과정을 위주로 정리해보겠다.

**LIS 자체를 구하는 방법이 아니라, LIS의 길이를 구하는 해법**이라는 것을 주의해야한다.

---

## 핵심 아이디어

“길이가 같은 증가 부분 수열 중 끝값이 가장 작은 것만 유지한다”는 관점

- 길이가 i인 증가 부분 수열이 여러 개 있다고 할 때, **그 마지막 원소(끝값)가 가장 작은 수열**이 이후 더 큰 수가 들어왔을 때 **확장**하기에 가장 유리하다.  
- 예를 들어, 길이가 2인 부분 수열 `[3, 9]`보다 `[3, 4]`의 끝값(4)이 더 작으므로, 나중에 숫자 8이 들어오면 `[3, 4, 8]`로 확장할 수 있다.

## 구현 방안

- 길이가 i인 부분 수열의 끝값을 배열 `sequence`의 인덱스 (i-1)에 저장한다.  
  - 즉, `sequence[k-1]`는 “길이가 k인 증가 부분 수열의 끝값”이다.  
- 새로운 원소 `x`가 들어왔을 때,
  1. `sequence`가 비어 있거나, `sequence`의 마지막 값보다 `x`가 더 크면 → 그대로 맨 뒤에 추가  
  2. 그렇지 않다면(더 크지 않다면) 이분 탐색을 통해 **`x`가 들어갈 위치**를 찾은 뒤, 그 위치의 원소를 `x`로 교체한다.  
  - 이렇게 교체함으로써, 길이는 유지하면서 **끝값을 더 작은 값으로 갱신**하여 이후 확장 가능성을 높인다.

최종적으로 `sequence.length`가 LIS의 길이가 된다. 실제 `sequence`가 LIS 원소들을 정확히 저장하지는 않지만, 길이는 항상 실제 LIS의 길이와 동일하다.

## 예시로 이해하기

- [3, 9]에 새로운 수 5가 들어오는 경우
   - LIS의 길이는 유지된다.
   - 3, 9, 5 중 길이가 2인 가능한 LIS는 [3, 9], [3, 5]가 있다.
   - [3, 9]의 경우 10 이상, [3, 5]의 경우 6 이상의 수가 들어와야 길이를 늘릴 수 있기 때문에 [3, 5]만 고려하면 된다.
   - 결론 : `sequence[1]`을 9에서 5로 교체

- [3, 4, 5]에 새로운 수 1이 들어오는 경우
   - LIS의 길이는 유지된다.
   - 3, 4, 5, 1 중 길이가 1인 LIS는 [3], [4], [5], [1]이 있다.
   - 같은 원리로 [1]이 끝값일 때 가장 확장 가능성이 높다.
   - `sequence[0]`을 3에서 1로 교체 

