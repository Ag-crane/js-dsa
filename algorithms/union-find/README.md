# 유니온 - 파인드(Union - Find) 알고리즘

### 분리 집합 (Disjoint Set)

`서로소 집합`, `상호 배타적 집합` 이라고도 부른다.
겹치는 원소가 없는 여러 개의 집합을 관리하는 자료구조이다.

-   여러 개의 집합이 존재하며, 각 원소는 정확히 하나의 집합에 속한다.
-   서로 다른 집합에 속한 원소들은 절대 겹치지 않는다.
-   유니온-파인드(Union-Find) 알고리즘을 활용하면, 합집합 연산(Union)과 대표 원소(=루트 노드) 찾기 연산(Find)을 효율적으로 수행할 수 있으며, 이를 통해 연결된 그룹을 빠르게 판별할 수 있다.

### 배열을 활용한 트리 구조

유니온 파인드에서는 집합을 **각 원소가 부모 노드를 가리키는 트리 구조**로 표현하고, 이를 배열로 구현한다.

-   `parent` 배열은 각 노드의 부모를 저장하는 배열이다. 인덱스는 노드를, 값은 해당 노드의 부모 노드를 의미한다.
-   루트 노드는 자기 자신을 부모 노드로 가진다. ➡️ `parent[x] === x`이면 `x`는 루트 노드

### Find 연산

특정 노드의 루트 노드를 탐색하는 연산이다.

-   재귀를 통해 부모 노드를 확인하는 과정을 반복하여 구현한다.
-   경로 압축 기법을 통해 O(1)에 가깝게 찾을 수 있다.
-   보통 특정 노드가 같은 집합에 있는지(=부모 노드가 같은지) 확인할 때 사용한다.

### 경로 압축 (Path Compression)

경로 압축은 트리 높이를 줄여서(=트리 구조를 평평하게 바꿔서) 루트 노드를 O(1)에 가깝게 찾을 수 있게 최적화하는 기법이다.
`find(x)` 연산 중 탐색한 모든 노드의 부모를 루트 노드로 직접 연결한다.

    한 번의 경로 압축으로 트리가 평평해지는데,
    왜 굳이 `find() 함수 안에서 매번 경로 압축을 수행해야 할까?

➡️ 새로운 `union` 연산이 일어날 때마다 트리 구조가 변화하기 때문이다. 이전 find() 연산에서 경로 압축을 했다 하더라도, 새로운 `union` 연산이 일어나면 트리 구조가 변하면서 경로 압축이 또 필요해질 수 있다. 때문에 find() 내부에서 매번 경로 압축을 수행하는 것이 효율적이다.

    왜 O(1)이 아니라 "O(1)에 가깝게" 라고 표현할까?

➡️ 모든 노드가 루트 노드를 가리키기 까지 여러 번의 경로 압축이 필요할 수 있기 때문이다. 경로 압축을 여러 번 실행하면 모든 노드가 루트 노드를 직접 가리키게 되지만, 초기 find() 호출에서는 여전히 깊이가 있을 수 있다. 연산이 반복되면서 점점 O(1) 수준으로 최적화된다.

### Union 연산

두 원소가 속한 집합을 하나로 합치는 연산이다. 두 집합의 루트 노드를 같게 하면 된다.

-   두 집합에서 각각 Find 연산을 통해 각 루트 노드를 찾는다.
-   두 루트 노드 중 하나를 다른 하나의 부모로 설정한다.

### Union by Rank

기본적인 Union 연산은 트리의 높이가 불필요하게 커질 가능성이 있다.
`Union by Rank` 기법을 적용하면, 불필요한 트리의 높이 증가를 방지할 수 있다. 랭크가 작은 트리를 랭크가 큰 트리에 연결하면 트리의 균형이 유지된다.

-   랭크(Rank) 는 해당 노드 기준 트리의 깊이(높이) 를 의미한다.
-   두 집합에서 각각 Find 연산을 통해 각각의 루트 노드를 찾는다.
-   루트 노드의 랭크를 비교하여 작은 랭크의 루트를 큰 랭크의 루트에 붙인다.
-   두 루트의 랭크가 같다면, 한쪽을 다른 쪽에 연결하고 새로운 루트의 랭크를 1 증가시킨다.

### 흐름 정리

-   초기 각 노드는 자기 자신을 루트 노드로 한다.
-   `Union` 연산을 거치며 트리가 만들어진다. (혹은 처음부터 트리가 주어질 수도)
-   `Union by Rank` 기법을 적용하여 불필요한 높이 증가를 방지한다.
-   `Find` 연산을 거치며 경로 압축을 통해 트리가 평평해지고, 이후 연산이 O(1) 수준으로 최적화된다.

### 주의 사항

-   `Union` 연산 시 `x, y`가 아니라 `rootX, rootY`의 부모와 랭크를 업데이트 해야한다.
-   `Union` 연산 시 `rootX === rootY`인 경우를 처리하지 않으면 불필요한 `rank` 증가가 발생한다.
