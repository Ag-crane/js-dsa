# 힙(Heap)

완전 이진 트리의 일종으로, 부모 노드가 자식 노드보다 항상 크거나(or 작거나) 같은 성질을 가지는 트리 구조이다.

영단어 힙(heap)은 '무엇인가를 차곡차곡 쌓아올린 더미'를 뜻한다.

삽입과 삭제가 O(log n)의 시간 복잡도를 가지므로, 효율적인 우선순위 처리가 필요한 상황에서 매우 유리하다.

일반적으로 우선순위 큐(Priority Queue)를 구현하는 데 사용된다.

다음 두 가지 형태로 나뉜다.

1. **최대 힙(Max Heap)**
부모 노드의 값이 항상 자식 노드의 값보다 크거나 같은 형태이다.
즉, 루트 노드가 항상 가장 큰 값을 가진다.

2. **최소 힙(Min Heap)**
부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은 형태이다.
즉, 루트 노드가 항상 가장 작은 값을 가진다.

---

### 완전 이진 트리 구조
- 마지막 레벨을 제외한 모든 레벨이 노드 꽉 차있으며, 마지막 레벨의 노드들도 왼쪽부터 차례대로 채워져 있는 이진 트리
- 트리 형태이지만, 배열로 구현하면 인덱스를 통해 부모 노드와 자식 노드 간의 관계를 표현할 수 있다.

---

### 자식/부모 인덱스 계산 방식
-  0-based 인덱싱
	- 부모 노드: parentIndex = (i - 1) // 2
	- 왼쪽 자식: leftChildIndex = 2 * i + 1
	- 오른쪽 자식: rightChildIndex = 2 * i + 2
- 1-based 인덱싱
	- 부모 노드: parentIndex = i // 2
	- 왼쪽 자식: leftChildIndex = 2 * i
	- 오른쪽 자식: rightChildIndex = 2 * i + 1

1-based 인덱싱에서는 수학적으로 조금 더 직관적인 식을 사용할 수 있지만, 실제로는 0번 인덱스를 비워 두거나 별도로 관리해야 하는 번거로움이 있다.
교과서적으로 힙을 설명할 때 1-based 인덱싱을 쓰는 예시가 많을 뿐, 실제 코드 구현에서는 **0-based 인덱싱이 주류**이다.

---

### 주요 연산
- 삽입 : O(logN)
	- 새 원소를 힙에 추가한다.
	- 원소를 마지막 위치에 추가한 후 부모 노드와 비교하여 힙 조건을 만족하도록 위치를 조정한다. 
	- 이를 '상향 힙(heapify-up, bubble-up, shift-up)'이라 부른다.
- 삭제 (delete) : O(logN)
	- 루트 노드(최대 힙에서는 최대값, 최소 힙에서는 최소값)를 제거한다.
	- 제거한 후 마지막 원소를 루트 위치로 옮기고, 다시 힙 조건을 만족하도록 위치를 조정한다. 
	- 이를 '하향 힙(heapify-down, bubble-down, shift-down)'이라 부른다.
- 조회(peek) : O(1)
루트 노드를 반환하며 제거하지는 않는다. 최대 힙의 경우 최댓값, 최소 힙의 경우 최솟값을 조회할 수 있다.

---

### 활용

1. 우선순위 큐(Priority Queue) 구현

2. 다익스트라 알고리즘과 같은 그래프 알고리즘에서 최단 경로 탐색

3. 힙 정렬(Heap Sort) 알고리즘

### 구현 시 주의사항
- swap 이후 다음 index 업데이트 하기
- 연산 전 index 초기화
	- bubbleUp에서는 while문 앞에서, 시작 노드(index)를 마지막 노드(heap.length-1)로.
	- bubbleDown에서는 while문 안에서, 가장 작은 노드(smallestIndex)를 현재 노드(index)로.
- bubbleDown에서 `childIndex > size` 조건 꼭 체크하기
- bubbleDown에서 childIndex 값과 비교 대상은 index 값이 아니라 smallestIndex 값이다.
