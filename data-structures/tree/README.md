# 이진 트리 (Binary Tree)

---

## 구현 방식 비교

### 배열

-   장점

    -   구현 난이도가 상대적으로 낮음. (인덱스를 통한 접근으로 구현이 직관적)

    -   메모리가 충분하다면 빠르게 구현 가능하고, 처리 로직이 간단함.

-   단점

    -   노드가 비어 있는(자식이 없는) 인덱스가 많아질 경우 메모리 낭비가 심함.

    -   완전 이진 트리 형태가 아니면 null로 채워진 공간이 크게 늘 수 있음.

-   추천 사용 상황

    -   완전 이진 트리에 가까운 경우. (예: 힙(Heap) 구조)

    -   레벨 순회가 자주 필요한 경우 (배열 인덱스 활용이 편리)

### 연결 리스트

-   장점

    -   인덱스 기반이 아니라 필요할 때만 노드를 할당하므로, 불필요한 공간 낭비가 적음.

    -   트리 구조가 바뀔 때(노드 추가·삭제)에 유연하게 대처 가능.

-   단점

    -   배열 기반에 비해 구현 난이도가 조금 높음. (포인터/참조 관리 필요)

    -   레벨 순회 등 인접 노드를 한 번에 다루려면 큐(Queue) 등을 별도로 사용해야 함.

-   추천 사용 상황

    -   트리의 형태가 불균형(완전 이진 트리가 아님)하거나 트리가 매우 클 때

    -   삽입·삭제 연산이 자주 일어나는 경우

### 선택 기준

1. 트리의 형태

    - 완전 이진 트리에 가까울수록 배열 방식에서 공간 낭비가 거의 없음.

    - 불균형 트리라면 연결 리스트 방식이 유리.

2. 트리의 크기

    - 작은 트리: 배열/연결 리스트 모두 가능.

    - 큰 트리: 배열 방식에 null이 많이 생길 수 있으므로 연결 리스트 방식이 메모리를 절약.

3. 삭제/삽입 연산 빈도

    - 연산이 많으면 연결 리스트 방식이 삽입·삭제에 더 적합.

4. 트리 순회 방식

    - 레벨 순회(BFS)가 중요하면 배열이 직관적(힙처럼 인덱스 사용).

    - DFS(전위, 중위, 후위 순회)는 두 방식 모두 무난.

---

## 순회

이진 트리를 순회하는 방법(DFS)에는 전위, 중위, 후위 순회가 있다.
핵심은 “현재 노드를 기준으로 왼쪽/오른쪽 자식을 방문하는 순서가 어떻게 되느냐” 이다.

1. 전위 순회 (Preorder):

-   부모 노드 → 왼쪽 자식 → 오른쪽 자식

-   지나는 노드를 우선 방문하므로, 트리 구조 파악이 직관적

-   트리 복사 시에 유용

2. 중위 순회 (Inorder):

-   왼쪽 자식 → 부모 노드 → 오른쪽 자식

-   이진 탐색 트리(BST)에서 정렬된 순서로 노드를 얻을 수 있음

3. 후위 순회 (Postorder):

-   왼쪽 자식 → 오른쪽 자식 → 부모 노드

-   자식 노드부터 방문하므로, 트리 삭제 같은 경우에 사용하면 편리

---

## 이진 탐색 트리 (BST: Binary Search Tree)

-   정의

    -   “왼쪽 서브트리는 루트보다 작은 값, 오른쪽 서브트리는 루트보다 큰 값”을 만족하는 이진 트리

    -   중복된 값은 일반적으로 허용하지 않거나, 별도의 처리 로직을 둠

-   특징

    -   삽입(Insert), 탐색(Search), 삭제(Delete) 모두 평균적으로 O(log N) 시간에 처리 가능

    -   중위 순회(Inorder)를 하면 오름차순(또는 내림차순)으로 값이 정렬됨

-   주의사항

    -   트리가 한쪽으로 치우치는(스케워) 구조가 되면 최악 O(N)까지 떨어질 수 있음

    -   균형 트리(AVL, Red-Black 등)를 사용하면 최악의 경우에도 O(log N)을 보장

-   사용 예시

    -   데이터 검색이 중요한 상황에서 단순 배열보다 빠른 탐색이 필요할 때

    -   삽입, 삭제와 검색을 모두 빠르게 수행해야 하는 경우 (일부 DB 인덱스 구조 등)
